
### 时长建模学习
- 思路1：TPM
- - 核心思路：
  - get_encoded_playtime（）
  - - 将不同时长之间的关系组织成一颗树，通过树根到叶子节点的路径的概率表达时长决策的概率，最终每个叶子节点的时长是路径的概率乘积
  - -  举例：对于16个叶子节点的树，所有的内部节点总共15个，那就需要学习15个分类器来进行最终决策如何从树根走到树的叶子节点
  - - 如何设置每个叶子节点代表的时长：通过对所有时长数据进行等频分桶成16个，使用每个分桶的边界均值【假设每个分桶的左边界是dur_margin_start，右边界是dur_margin_end】 temp_encoded_playtime=(dur_margin_start + dur_margin_end)/2 来代表分桶下的目标时长
  - - 模型的预估的时长 encoded_playtime = tf.reduce_sum(temp_encoded_playtime*encoded_prob,axis=-1,keepdims=True)，其中encoded_prob是叶子分桶的概率列表，encoded_playtime是叶子子分桶的边界均值列表
  - - 计算所有区间中点的平方的期望值e_x2: E[X^2] = sum(区间中点^2 * 概率)
  - - - e_x2 = tf.reduce_sum(tf.square(temp_encoded_playtime)*encoded_prob, axis=-1,keepdims=True)
  - - 计算期望值的平方
  - - - square_of_e_x = tf.square(encoded_playtime)
  - - 计算标准差
  - - -  var = tf.sqrt(e_x2 - square_of_e_x)
  - 
