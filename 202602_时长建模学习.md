
### 时长建模学习
- 思路1：D2Q
- - 核心思路：将数据按视频时长划分不同分组，对于每个分组学习回归模型去预测观看时长分位数【根据时长分组消除duration bias】，使用mse进行训练
  - 模型结构：所有分组共用同一个模型，只输入一个0到1的值，将时长分组作embedding拼接到模型的中间层。
- 思路2：TPM
- - 核心思路：将不同时长之间的关系组成一个树，从树根到叶子节点的概率乘积就是叶子节点取值的最后概率。
  - 训练损失：
  - - 损失1：loss_op_mse=mse(dur,pred_dur) 时长的回归
    - 损失2：loss_op= LR(pnode,pnode_rate) 时长树路径的概率学习
    - 损失3：var  构建预估dur中的标准差 【预估时长平方的期望-预估时长期望的平方】
- - 重要函数
  - get_encoded_playtime（）
  - - 将不同时长之间的关系组织成一颗树，通过树根到叶子节点的路径的概率表达时长决策的概率，最终每个叶子节点的时长是路径的概率乘积
  - -  举例：对于16个叶子节点的树，所有的内部节点总共15个，那就需要学习15个分类器来进行最终决策如何从树根走到树的叶子节点
  - - 如何设置每个叶子节点代表的时长：通过对所有时长数据进行等频分桶成16个，使用每个分桶的边界均值【假设每个分桶的左边界是dur_margin_start，右边界是dur_margin_end】 temp_encoded_playtime=(dur_margin_start + dur_margin_end)/2 来代表分桶下的目标时长
  - - 模型的预估的时长 encoded_playtime = tf.reduce_sum(temp_encoded_playtime*encoded_prob,axis=-1,keepdims=True)，其中encoded_prob是叶子分桶的概率列表，encoded_playtime是叶子子分桶的边界均值列表
  - - 计算所有区间中点的平方的期望值e_x2: E[X^2] = sum(区间中点^2 * 概率)
  - - - e_x2 = tf.reduce_sum(tf.square(encoded_playtime)*encoded_prob, axis=-1,keepdims=True)
  - - 计算期望值的平方
  - - - square_of_e_x = tf.square(encoded_playtime)
  - - 计算标准差
  - - -  var = tf.sqrt(e_x2 - square_of_e_x)
